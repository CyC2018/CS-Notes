<!-- GFM-TOC -->
* [é€’å½’](#é€’å½’)
    * [æ ‘çš„é«˜åº¦](#æ ‘çš„é«˜åº¦)
    * [å¹³è¡¡æ ‘](#å¹³è¡¡æ ‘)
    * [ä¸¤èŠ‚ç‚¹çš„æœ€é•¿è·¯å¾„](#ä¸¤èŠ‚ç‚¹çš„æœ€é•¿è·¯å¾„)
    * [ç¿»è½¬æ ‘](#ç¿»è½¬æ ‘)
    * [å½’å¹¶ä¸¤æ£µæ ‘](#å½’å¹¶ä¸¤æ£µæ ‘)
    * [åˆ¤æ–­è·¯å¾„å’Œæ˜¯å¦ç­‰äºä¸€ä¸ªæ•°](#åˆ¤æ–­è·¯å¾„å’Œæ˜¯å¦ç­‰äºä¸€ä¸ªæ•°)
    * [ç»Ÿè®¡è·¯å¾„å’Œç­‰äºä¸€ä¸ªæ•°çš„è·¯å¾„æ•°é‡](#ç»Ÿè®¡è·¯å¾„å’Œç­‰äºä¸€ä¸ªæ•°çš„è·¯å¾„æ•°é‡)
    * [å­æ ‘](#å­æ ‘)
    * [æ ‘çš„å¯¹ç§°](#æ ‘çš„å¯¹ç§°)
    * [æœ€å°è·¯å¾„](#æœ€å°è·¯å¾„)
    * [ç»Ÿè®¡å·¦å¶å­èŠ‚ç‚¹çš„å’Œ](#ç»Ÿè®¡å·¦å¶å­èŠ‚ç‚¹çš„å’Œ)
    * [ç›¸åŒèŠ‚ç‚¹å€¼çš„æœ€å¤§è·¯å¾„é•¿åº¦](#ç›¸åŒèŠ‚ç‚¹å€¼çš„æœ€å¤§è·¯å¾„é•¿åº¦)
    * [é—´éš”éå†](#é—´éš”éå†)
    * [æ‰¾å‡ºäºŒå‰æ ‘ä¸­ç¬¬äºŒå°çš„èŠ‚ç‚¹](#æ‰¾å‡ºäºŒå‰æ ‘ä¸­ç¬¬äºŒå°çš„èŠ‚ç‚¹)
* [å±‚æ¬¡éå†](#å±‚æ¬¡éå†)
    * [ä¸€æ£µæ ‘æ¯å±‚èŠ‚ç‚¹çš„å¹³å‡æ•°](#ä¸€æ£µæ ‘æ¯å±‚èŠ‚ç‚¹çš„å¹³å‡æ•°)
    * [å¾—åˆ°å·¦ä¸‹è§’çš„èŠ‚ç‚¹](#å¾—åˆ°å·¦ä¸‹è§’çš„èŠ‚ç‚¹)
* [å‰ä¸­ååºéå†](#å‰ä¸­ååºéå†)
    * [éé€’å½’å®ç°äºŒå‰æ ‘çš„å‰åºéå†](#éé€’å½’å®ç°äºŒå‰æ ‘çš„å‰åºéå†)
    * [éé€’å½’å®ç°äºŒå‰æ ‘çš„ååºéå†](#éé€’å½’å®ç°äºŒå‰æ ‘çš„ååºéå†)
    * [éé€’å½’å®ç°äºŒå‰æ ‘çš„ä¸­åºéå†](#éé€’å½’å®ç°äºŒå‰æ ‘çš„ä¸­åºéå†)
* [BST](#bst)
    * [ä¿®å‰ªäºŒå‰æŸ¥æ‰¾æ ‘](#ä¿®å‰ªäºŒå‰æŸ¥æ‰¾æ ‘)
    * [å¯»æ‰¾äºŒå‰æŸ¥æ‰¾æ ‘çš„ç¬¬ k ä¸ªå…ƒç´ ](#å¯»æ‰¾äºŒå‰æŸ¥æ‰¾æ ‘çš„ç¬¬-k-ä¸ªå…ƒç´ )
    * [æŠŠäºŒå‰æŸ¥æ‰¾æ ‘æ¯ä¸ªèŠ‚ç‚¹çš„å€¼éƒ½åŠ ä¸Šæ¯”å®ƒå¤§çš„èŠ‚ç‚¹çš„å€¼](#æŠŠäºŒå‰æŸ¥æ‰¾æ ‘æ¯ä¸ªèŠ‚ç‚¹çš„å€¼éƒ½åŠ ä¸Šæ¯”å®ƒå¤§çš„èŠ‚ç‚¹çš„å€¼)
    * [äºŒå‰æŸ¥æ‰¾æ ‘çš„æœ€è¿‘å…¬å…±ç¥–å…ˆ](#äºŒå‰æŸ¥æ‰¾æ ‘çš„æœ€è¿‘å…¬å…±ç¥–å…ˆ)
    * [äºŒå‰æ ‘çš„æœ€è¿‘å…¬å…±ç¥–å…ˆ](#äºŒå‰æ ‘çš„æœ€è¿‘å…¬å…±ç¥–å…ˆ)
    * [ä»æœ‰åºæ•°ç»„ä¸­æ„é€ äºŒå‰æŸ¥æ‰¾æ ‘](#ä»æœ‰åºæ•°ç»„ä¸­æ„é€ äºŒå‰æŸ¥æ‰¾æ ‘)
    * [æ ¹æ®æœ‰åºé“¾è¡¨æ„é€ å¹³è¡¡çš„äºŒå‰æŸ¥æ‰¾æ ‘](#æ ¹æ®æœ‰åºé“¾è¡¨æ„é€ å¹³è¡¡çš„äºŒå‰æŸ¥æ‰¾æ ‘)
    * [åœ¨äºŒå‰æŸ¥æ‰¾æ ‘ä¸­å¯»æ‰¾ä¸¤ä¸ªèŠ‚ç‚¹ï¼Œä½¿å®ƒä»¬çš„å’Œä¸ºä¸€ä¸ªç»™å®šå€¼](#åœ¨äºŒå‰æŸ¥æ‰¾æ ‘ä¸­å¯»æ‰¾ä¸¤ä¸ªèŠ‚ç‚¹ï¼Œä½¿å®ƒä»¬çš„å’Œä¸ºä¸€ä¸ªç»™å®šå€¼)
    * [åœ¨äºŒå‰æŸ¥æ‰¾æ ‘ä¸­æŸ¥æ‰¾ä¸¤ä¸ªèŠ‚ç‚¹ä¹‹å·®çš„æœ€å°ç»å¯¹å€¼](#åœ¨äºŒå‰æŸ¥æ‰¾æ ‘ä¸­æŸ¥æ‰¾ä¸¤ä¸ªèŠ‚ç‚¹ä¹‹å·®çš„æœ€å°ç»å¯¹å€¼)
    * [å¯»æ‰¾äºŒå‰æŸ¥æ‰¾æ ‘ä¸­å‡ºç°æ¬¡æ•°æœ€å¤šçš„å€¼](#å¯»æ‰¾äºŒå‰æŸ¥æ‰¾æ ‘ä¸­å‡ºç°æ¬¡æ•°æœ€å¤šçš„å€¼)
* [Trie](#trie)
    * [å®ç°ä¸€ä¸ª Trie](#å®ç°ä¸€ä¸ª-trie)
    * [å®ç°ä¸€ä¸ª Trieï¼Œç”¨æ¥æ±‚å‰ç¼€å’Œ](#å®ç°ä¸€ä¸ª-trieï¼Œç”¨æ¥æ±‚å‰ç¼€å’Œ)
<!-- GFM-TOC -->


# é€’å½’

ä¸€æ£µæ ‘è¦ä¹ˆæ˜¯ç©ºæ ‘ï¼Œè¦ä¹ˆæœ‰ä¸¤ä¸ªæŒ‡é’ˆï¼Œæ¯ä¸ªæŒ‡é’ˆæŒ‡å‘ä¸€æ£µæ ‘ã€‚æ ‘æ˜¯ä¸€ç§é€’å½’ç»“æ„ï¼Œå¾ˆå¤šæ ‘çš„é—®é¢˜å¯ä»¥ä½¿ç”¨é€’å½’æ¥å¤„ç†ã€‚

## æ ‘çš„é«˜åº¦

[104. Maximum Depth of Binary Tree (Easy)](https://leetcode.com/problems/maximum-depth-of-binary-tree/description/)

```java
public int maxDepth(TreeNode root) {
    if (root == null) return 0;
    return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;
}
```

## å¹³è¡¡æ ‘

[110. Balanced Binary Tree (Easy)](https://leetcode.com/problems/balanced-binary-tree/description/)

```html
    3
   / \
  9  20
    /  \
   15   7
```

å¹³è¡¡æ ‘å·¦å³å­æ ‘é«˜åº¦å·®éƒ½å°äºç­‰äº 1

```java
private boolean result = true;

public boolean isBalanced(TreeNode root) {
    maxDepth(root);
    return result;
}

public int maxDepth(TreeNode root) {
    if (root == null) return 0;
    int l = maxDepth(root.left);
    int r = maxDepth(root.right);
    if (Math.abs(l - r) > 1) result = false;
    return 1 + Math.max(l, r);
}
```

## ä¸¤èŠ‚ç‚¹çš„æœ€é•¿è·¯å¾„

[543. Diameter of Binary Tree (Easy)](https://leetcode.com/problems/diameter-of-binary-tree/description/)

```html
Input:

         1
        / \
       2  3
      / \
     4   5

Return 3, which is the length of the path [4,2,1,3] or [5,2,1,3].
```

```java
private int max = 0;

public int diameterOfBinaryTree(TreeNode root) {
    depth(root);
    return max;
}

private int depth(TreeNode root) {
    if (root == null) return 0;
    int leftDepth = depth(root.left);
    int rightDepth = depth(root.right);
    max = Math.max(max, leftDepth + rightDepth);
    return Math.max(leftDepth, rightDepth) + 1;
}
```

## ç¿»è½¬æ ‘

[226. Invert Binary Tree (Easy)](https://leetcode.com/problems/invert-binary-tree/description/)

```java
public TreeNode invertTree(TreeNode root) {
    if (root == null) return null;
    TreeNode left = root.left;  // åé¢çš„æ“ä½œä¼šæ”¹å˜ left æŒ‡é’ˆï¼Œå› æ­¤å…ˆä¿å­˜ä¸‹æ¥
    root.left = invertTree(root.right);
    root.right = invertTree(left);
    return root;
}
```

## å½’å¹¶ä¸¤æ£µæ ‘

[617. Merge Two Binary Trees (Easy)](https://leetcode.com/problems/merge-two-binary-trees/description/)

```html
Input:
       Tree 1                     Tree 2
          1                         2
         / \                       / \
        3   2                     1   3
       /                           \   \
      5                             4   7

Output:
         3
        / \
       4   5
      / \   \
     5   4   7
```

```java
public TreeNode mergeTrees(TreeNode t1, TreeNode t2) {
    if (t1 == null && t2 == null) return null;
    if (t1 == null) return t2;
    if (t2 == null) return t1;
    TreeNode root = new TreeNode(t1.val + t2.val);
    root.left = mergeTrees(t1.left, t2.left);
    root.right = mergeTrees(t1.right, t2.right);
    return root;
}
```

## åˆ¤æ–­è·¯å¾„å’Œæ˜¯å¦ç­‰äºä¸€ä¸ªæ•°

[Leetcdoe : 112. Path Sum (Easy)](https://leetcode.com/problems/path-sum/description/)

```html
Given the below binary tree and sum = 22,

              5
             / \
            4   8
           /   / \
          11  13  4
         /  \      \
        7    2      1

return true, as there exist a root-to-leaf path 5->4->11->2 which sum is 22.
```

è·¯å¾„å’Œå®šä¹‰ä¸ºä» root åˆ° leaf çš„æ‰€æœ‰èŠ‚ç‚¹çš„å’Œã€‚

```java
public boolean hasPathSum(TreeNode root, int sum) {
    if (root == null) return false;
    if (root.left == null && root.right == null && root.val == sum) return true;
    return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);
}
```

## ç»Ÿè®¡è·¯å¾„å’Œç­‰äºä¸€ä¸ªæ•°çš„è·¯å¾„æ•°é‡

[437. Path Sum III (Easy)](https://leetcode.com/problems/path-sum-iii/description/)

```html
root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8

      10
     /  \
    5   -3
   / \    \
  3   2   11
 / \   \
3  -2   1

Return 3. The paths that sum to 8 are:

1.  5 -> 3
2.  5 -> 2 -> 1
3. -3 -> 11
```

è·¯å¾„ä¸ä¸€å®šä»¥ root å¼€å¤´ï¼Œä¹Ÿä¸ä¸€å®šä»¥ leaf ç»“å°¾ï¼Œä½†æ˜¯å¿…é¡»è¿ç»­ã€‚

```java
public int pathSum(TreeNode root, int sum) {
    if (root == null) return 0;
    int ret = pathSumStartWithRoot(root, sum) + pathSum(root.left, sum) + pathSum(root.right, sum);
    return ret;
}

private int pathSumStartWithRoot(TreeNode root, int sum) {
    if (root == null) return 0;
    int ret = 0;
    if (root.val == sum) ret++;
    ret += pathSumStartWithRoot(root.left, sum - root.val) + pathSumStartWithRoot(root.right, sum - root.val);
    return ret;
}
```

## å­æ ‘

[572. Subtree of Another Tree (Easy)](https://leetcode.com/problems/subtree-of-another-tree/description/)

```html
Given tree s:
     3
    / \
   4   5
  / \
 1   2

Given tree t:
   4
  / \
 1   2

Return true, because t has the same structure and node values with a subtree of s.

Given tree s:

     3
    / \
   4   5
  / \
 1   2
    /
   0

Given tree t:
   4
  / \
 1   2

Return false.
```

```java
public boolean isSubtree(TreeNode s, TreeNode t) {
    if (s == null) return false;
    return isSubtreeWithRoot(s, t) || isSubtree(s.left, t) || isSubtree(s.right, t);
}

private boolean isSubtreeWithRoot(TreeNode s, TreeNode t) {
    if (t == null && s == null) return true;
    if (t == null || s == null) return false;
    if (t.val != s.val) return false;
    return isSubtreeWithRoot(s.left, t.left) && isSubtreeWithRoot(s.right, t.right);
}
```

## æ ‘çš„å¯¹ç§°

[101. Symmetric Tree (Easy)](https://leetcode.com/problems/symmetric-tree/description/)

```html
    1
   / \
  2   2
 / \ / \
3  4 4  3
```

```java
public boolean isSymmetric(TreeNode root) {
    if (root == null) return true;
    return isSymmetric(root.left, root.right);
}

private boolean isSymmetric(TreeNode t1, TreeNode t2) {
    if (t1 == null && t2 == null) return true;
    if (t1 == null || t2 == null) return false;
    if (t1.val != t2.val) return false;
    return isSymmetric(t1.left, t2.right) && isSymmetric(t1.right, t2.left);
}
```

## æœ€å°è·¯å¾„

[111. Minimum Depth of Binary Tree (Easy)](https://leetcode.com/problems/minimum-depth-of-binary-tree/description/)

æ ‘çš„æ ¹èŠ‚ç‚¹åˆ°å¶å­èŠ‚ç‚¹çš„æœ€å°è·¯å¾„é•¿åº¦

```java
public int minDepth(TreeNode root) {
    if (root == null) return 0;
    int left = minDepth(root.left);
    int right = minDepth(root.right);
    if (left == 0 || right == 0) return left + right + 1;
    return Math.min(left, right) + 1;
}
```

## ç»Ÿè®¡å·¦å¶å­èŠ‚ç‚¹çš„å’Œ

[404. Sum of Left Leaves (Easy)](https://leetcode.com/problems/sum-of-left-leaves/description/)

```html
    3
   / \
  9  20
    /  \
   15   7

There are two left leaves in the binary tree, with values 9 and 15 respectively. Return 24.
```

```java
public int sumOfLeftLeaves(TreeNode root) {
    if (root == null) return 0;
    if (isLeaf(root.left)) return root.left.val + sumOfLeftLeaves(root.right);
    return sumOfLeftLeaves(root.left) + sumOfLeftLeaves(root.right);
}

private boolean isLeaf(TreeNode node){
    if (node == null) return false;
    return node.left == null && node.right == null;
}
```

## ç›¸åŒèŠ‚ç‚¹å€¼çš„æœ€å¤§è·¯å¾„é•¿åº¦

[687. Longest Univalue Path (Easy)](https://leetcode.com/problems/longest-univalue-path/)

```html
             1
            / \
           4   5
          / \   \
         4   4   5

Output : 2
```

```java
private int path = 0;

public int longestUnivaluePath(TreeNode root) {
    dfs(root);
    return path;
}

private int dfs(TreeNode root){
    if (root == null) return 0;
    int left = dfs(root.left);
    int right = dfs(root.right);
    int leftPath = root.left != null && root.left.val == root.val ? left + 1 : 0;
    int rightPath = root.right != null && root.right.val == root.val ? right + 1 : 0;
    path = Math.max(path, leftPath + rightPath);
    return Math.max(leftPath, rightPath);
}
```

## é—´éš”éå†

[337. House Robber III (Medium)](https://leetcode.com/problems/house-robber-iii/description/)

```html
     3
    / \
   2   3
    \   \
     3   1
Maximum amount of money the thief can rob = 3 + 3 + 1 = 7.
```

```java
public int rob(TreeNode root) {
    if (root == null) return 0;
    int val1 = root.val;
    if (root.left != null) val1 += rob(root.left.left) + rob(root.left.right);
    if (root.right != null) val1 += rob(root.right.left) + rob(root.right.right);
    int val2 = rob(root.left) + rob(root.right);
    return Math.max(val1, val2);
}
```

## æ‰¾å‡ºäºŒå‰æ ‘ä¸­ç¬¬äºŒå°çš„èŠ‚ç‚¹

[671. Second Minimum Node In a Binary Tree (Easy)](https://leetcode.com/problems/second-minimum-node-in-a-binary-tree/description/)

```html
Input:
   2
  / \
 2   5
    / \
    5  7

Output: 5
```

ä¸€ä¸ªèŠ‚ç‚¹è¦ä¹ˆå…·æœ‰ 0 ä¸ªæˆ– 2 ä¸ªå­èŠ‚ç‚¹ï¼Œå¦‚æœæœ‰å­èŠ‚ç‚¹ï¼Œé‚£ä¹ˆæ ¹èŠ‚ç‚¹æ˜¯æœ€å°çš„èŠ‚ç‚¹ã€‚

```java
public int findSecondMinimumValue(TreeNode root) {
    if (root == null) return -1;
    if (root.left == null && root.right == null) return -1;
    int leftVal = root.left.val;
    int rightVal = root.right.val;
    if (leftVal == root.val) leftVal = findSecondMinimumValue(root.left);
    if (rightVal == root.val) rightVal = findSecondMinimumValue(root.right);
    if (leftVal != -1 && rightVal != -1) return Math.min(leftVal, rightVal);
    if (leftVal != -1) return leftVal;
    return rightVal;
}
```

# å±‚æ¬¡éå†

ä½¿ç”¨ BFS è¿›è¡Œå±‚æ¬¡éå†ã€‚ä¸éœ€è¦ä½¿ç”¨ä¸¤ä¸ªé˜Ÿåˆ—æ¥åˆ†åˆ«å­˜å‚¨å½“å‰å±‚çš„èŠ‚ç‚¹å’Œä¸‹ä¸€å±‚çš„èŠ‚ç‚¹ï¼Œå› ä¸ºåœ¨å¼€å§‹éå†ä¸€å±‚çš„èŠ‚ç‚¹æ—¶ï¼Œå½“å‰é˜Ÿåˆ—ä¸­çš„èŠ‚ç‚¹æ•°å°±æ˜¯å½“å‰å±‚çš„èŠ‚ç‚¹æ•°ï¼Œåªè¦æ§åˆ¶éå†è¿™ä¹ˆå¤šèŠ‚ç‚¹æ•°ï¼Œå°±èƒ½ä¿è¯è¿™æ¬¡éå†çš„éƒ½æ˜¯å½“å‰å±‚çš„èŠ‚ç‚¹ã€‚

## ä¸€æ£µæ ‘æ¯å±‚èŠ‚ç‚¹çš„å¹³å‡æ•°

[637. Average of Levels in Binary Tree (Easy)](https://leetcode.com/problems/average-of-levels-in-binary-tree/description/)

```java
public List<Double> averageOfLevels(TreeNode root) {
    List<Double> ret = new ArrayList<>();
    if (root == null) return ret;
    Queue<TreeNode> queue = new LinkedList<>();
    queue.add(root);
    while (!queue.isEmpty()) {
        int cnt = queue.size();
        double sum = 0;
        for (int i = 0; i < cnt; i++) {
            TreeNode node = queue.poll();
            sum += node.val;
            if (node.left != null) queue.add(node.left);
            if (node.right != null) queue.add(node.right);
        }
        ret.add(sum / cnt);
    }
    return ret;
}
```

## å¾—åˆ°å·¦ä¸‹è§’çš„èŠ‚ç‚¹

[513. Find Bottom Left Tree Value (Easy)](https://leetcode.com/problems/find-bottom-left-tree-value/description/)

```html
Input:

        1
       / \
      2   3
     /   / \
    4   5   6
       /
      7

Output:
7
```

```java
public int findBottomLeftValue(TreeNode root) {
    Queue<TreeNode> queue = new LinkedList<>();
    queue.add(root);
    while (!queue.isEmpty()) {
        root = queue.poll();
        if (root.right != null) queue.add(root.right);
        if (root.left != null) queue.add(root.left);
    }
    return root.val;
}
```

# å‰ä¸­ååºéå†

```html
    1
   / \
  2   3
 / \   \
4   5   6
```

- å±‚æ¬¡éå†é¡ºåºï¼š[1 2 3 4 5 6]
- å‰åºéå†é¡ºåºï¼š[1 2 4 5 3 6]
- ä¸­åºéå†é¡ºåºï¼š[4 2 5 1 3 6]
- ååºéå†é¡ºåºï¼š[4 5 2 6 3 1]

å±‚æ¬¡éå†ä½¿ç”¨ BFS å®ç°ï¼Œåˆ©ç”¨çš„å°±æ˜¯ BFS ä¸€å±‚ä¸€å±‚éå†çš„ç‰¹æ€§ï¼›è€Œå‰åºã€ä¸­åºã€ååºéå†åˆ©ç”¨äº† DFS å®ç°ã€‚

å‰åºã€ä¸­åºã€ååºéåªæ˜¯åœ¨å¯¹èŠ‚ç‚¹è®¿é—®çš„é¡ºåºæœ‰ä¸€ç‚¹ä¸åŒï¼Œå…¶å®ƒéƒ½ç›¸åŒã€‚

â‘  å‰åº

```java
void dfs(TreeNode root) {
    visit(root);
    dfs(root.left);
    dfs(root.right);
}
```

â‘¡ ä¸­åº

```java
void dfs(TreeNode root) {
    dfs(root.left);
    visit(root);
    dfs(root.right);
}
```

â‘¢ ååº

```java
void dfs(TreeNode root) {
    dfs(root.left);
    dfs(root.right);
    visit(root);
}
```

## éé€’å½’å®ç°äºŒå‰æ ‘çš„å‰åºéå†

[144. Binary Tree Preorder Traversal (Medium)](https://leetcode.com/problems/binary-tree-preorder-traversal/description/)

```java
public List<Integer> preorderTraversal(TreeNode root) {
    List<Integer> ret = new ArrayList<>();
    Stack<TreeNode> stack = new Stack<>();
    stack.push(root);
    while (!stack.isEmpty()) {
        TreeNode node = stack.pop();
        if (node == null) continue;
        ret.add(node.val);
        stack.push(node.right);  // å…ˆå³åå·¦ï¼Œä¿è¯å·¦å­æ ‘å…ˆéå†
        stack.push(node.left);
    }
    return ret;
}
```

## éé€’å½’å®ç°äºŒå‰æ ‘çš„ååºéå†

[145. Binary Tree Postorder Traversal (Medium)](https://leetcode.com/problems/binary-tree-postorder-traversal/description/)

å‰åºéå†ä¸º root -> left -> rightï¼Œååºéå†ä¸º left -> right -> rootã€‚å¯ä»¥ä¿®æ”¹å‰åºéå†æˆä¸º root -> right -> leftï¼Œé‚£ä¹ˆè¿™ä¸ªé¡ºåºå°±å’Œååºéå†æ­£å¥½ç›¸åã€‚

```java
public List<Integer> postorderTraversal(TreeNode root) {
    List<Integer> ret = new ArrayList<>();
    Stack<TreeNode> stack = new Stack<>();
    stack.push(root);
    while (!stack.isEmpty()) {
        TreeNode node = stack.pop();
        if (node == null) continue;
        ret.add(node.val);
        stack.push(node.left);
        stack.push(node.right);
    }
    Collections.reverse(ret);
    return ret;
}
```

## éé€’å½’å®ç°äºŒå‰æ ‘çš„ä¸­åºéå†

[94. Binary Tree Inorder Traversal (Medium)](https://leetcode.com/problems/binary-tree-inorder-traversal/description/)

```java
public List<Integer> inorderTraversal(TreeNode root) {
    List<Integer> ret = new ArrayList<>();
    if (root == null) return ret;
    Stack<TreeNode> stack = new Stack<>();
    TreeNode cur = root;
    while (cur != null || !stack.isEmpty()) {
        while (cur != null) {
            stack.push(cur);
            cur = cur.left;
        }
        TreeNode node = stack.pop();
        ret.add(node.val);
        cur = node.right;
    }
    return ret;
}
```

# BST

äºŒå‰æŸ¥æ‰¾æ ‘ï¼ˆBSTï¼‰ï¼šæ ¹èŠ‚ç‚¹å¤§äºç­‰äºå·¦å­æ ‘æ‰€æœ‰èŠ‚ç‚¹ï¼Œå°äºç­‰äºå³å­æ ‘æ‰€æœ‰èŠ‚ç‚¹ã€‚

äºŒå‰æŸ¥æ‰¾æ ‘ä¸­åºéå†æœ‰åºã€‚

## ä¿®å‰ªäºŒå‰æŸ¥æ‰¾æ ‘

[669. Trim a Binary Search Tree (Easy)](https://leetcode.com/problems/trim-a-binary-search-tree/description/)

```html
Input:

    3
   / \
  0   4
   \
    2
   /
  1

  L = 1
  R = 3

Output:

      3
     /
   2
  /
 1
```

é¢˜ç›®æè¿°ï¼šåªä¿ç•™å€¼åœ¨ L \~ R ä¹‹é—´çš„èŠ‚ç‚¹

```java
public TreeNode trimBST(TreeNode root, int L, int R) {
    if (root == null) return null;
    if (root.val > R) return trimBST(root.left, L, R);
    if (root.val < L) return trimBST(root.right, L, R);
    root.left = trimBST(root.left, L, R);
    root.right = trimBST(root.right, L, R);
    return root;
}
```

## å¯»æ‰¾äºŒå‰æŸ¥æ‰¾æ ‘çš„ç¬¬ k ä¸ªå…ƒç´ 

[230. Kth Smallest Element in a BST (Medium)](https://leetcode.com/problems/kth-smallest-element-in-a-bst/description/)


ä¸­åºéå†è§£æ³•ï¼š

```java
private int cnt = 0;
private int val;

public int kthSmallest(TreeNode root, int k) {
    inOrder(root, k);
    return val;
}

private void inOrder(TreeNode node, int k) {
    if (node == null) return;
    inOrder(node.left, k);
    cnt++;
    if (cnt == k) {
        val = node.val;
        return;
    }
    inOrder(node.right, k);
}
```

é€’å½’è§£æ³•ï¼š

```java
public int kthSmallest(TreeNode root, int k) {
    int leftCnt = count(root.left);
    if (leftCnt == k - 1) return root.val;
    if (leftCnt > k - 1) return kthSmallest(root.left, k);
    return kthSmallest(root.right, k - leftCnt - 1);
}

private int count(TreeNode node) {
    if (node == null) return 0;
    return 1 + count(node.left) + count(node.right);
}
```

## æŠŠäºŒå‰æŸ¥æ‰¾æ ‘æ¯ä¸ªèŠ‚ç‚¹çš„å€¼éƒ½åŠ ä¸Šæ¯”å®ƒå¤§çš„èŠ‚ç‚¹çš„å€¼

[Convert BST to Greater Tree (Easy)](https://leetcode.com/problems/convert-bst-to-greater-tree/description/)

```html
Input: The root of a Binary Search Tree like this:

              5
            /   \
           2     13

Output: The root of a Greater Tree like this:

             18
            /   \
          20     13
```

å…ˆéå†å³å­æ ‘ã€‚

```java
private int sum = 0;

public TreeNode convertBST(TreeNode root) {
    traver(root);
    return root;
}

private void traver(TreeNode node) {
    if (node == null) return;
    traver(node.right);
    sum += node.val;
    node.val = sum;
    traver(node.left);
}
```

## äºŒå‰æŸ¥æ‰¾æ ‘çš„æœ€è¿‘å…¬å…±ç¥–å…ˆ

[235. Lowest Common Ancestor of a Binary Search Tree (Easy)](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/description/)

```html
        _______6______
      /                \
  ___2__             ___8__
 /      \           /      \
0        4         7        9
        /  \
       3   5

For example, the lowest common ancestor (LCA) of nodes 2 and 8 is 6. Another example is LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition.
```

```java
public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
    if (root.val > p.val && root.val > q.val) return lowestCommonAncestor(root.left, p, q);
    if (root.val < p.val && root.val < q.val) return lowestCommonAncestor(root.right, p, q);
    return root;
}
```

## äºŒå‰æ ‘çš„æœ€è¿‘å…¬å…±ç¥–å…ˆ

[236. Lowest Common Ancestor of a Binary Tree (Medium) ](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/description/)

```html
       _______3______
      /              \
  ___5__           ___1__
 /      \         /      \
6        2       0        8
        /  \
       7    4

For example, the lowest common ancestor (LCA) of nodes 5 and 1 is 3. Another example is LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition.
```

```java
public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
    if (root == null || root == p || root == q) return root;
    TreeNode left = lowestCommonAncestor(root.left, p, q);
    TreeNode right = lowestCommonAncestor(root.right, p, q);
    return left == null ? right : right == null ? left : root;
}
```

## ä»æœ‰åºæ•°ç»„ä¸­æ„é€ äºŒå‰æŸ¥æ‰¾æ ‘

[108. Convert Sorted Array to Binary Search Tree (Easy)](https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/description/)

```java
public TreeNode sortedArrayToBST(int[] nums) {
    return toBST(nums, 0, nums.length - 1);
}

private TreeNode toBST(int[] nums, int sIdx, int eIdx){
    if (sIdx > eIdx) return null;
    int mIdx = (sIdx + eIdx) / 2;
    TreeNode root = new TreeNode(nums[mIdx]);
    root.left =  toBST(nums, sIdx, mIdx - 1);
    root.right = toBST(nums, mIdx + 1, eIdx);
    return root;
}
```

## æ ¹æ®æœ‰åºé“¾è¡¨æ„é€ å¹³è¡¡çš„äºŒå‰æŸ¥æ‰¾æ ‘

[109. Convert Sorted List to Binary Search Tree (Medium)](https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/description/)

```html
Given the sorted linked list: [-10,-3,0,5,9],

One possible answer is: [0,-3,9,-10,null,5], which represents the following height balanced BST:

      0
     / \
   -3   9
   /   /
 -10  5
```

```java
public TreeNode sortedListToBST(ListNode head) {
    if (head == null) return null;
    if (head.next == null) return new TreeNode(head.val);
    ListNode preMid = preMid(head);
    ListNode mid = preMid.next;
    preMid.next = null;  // æ–­å¼€é“¾è¡¨
    TreeNode t = new TreeNode(mid.val);
    t.left = sortedListToBST(head);
    t.right = sortedListToBST(mid.next);
    return t;
}

private ListNode preMid(ListNode head) {
    ListNode slow = head, fast = head.next;
    ListNode pre = head;
    while (fast != null && fast.next != null) {
        pre = slow;
        slow = slow.next;
        fast = fast.next.next;
    }
    return pre;
}
```

## åœ¨äºŒå‰æŸ¥æ‰¾æ ‘ä¸­å¯»æ‰¾ä¸¤ä¸ªèŠ‚ç‚¹ï¼Œä½¿å®ƒä»¬çš„å’Œä¸ºä¸€ä¸ªç»™å®šå€¼

[653. Two Sum IV - Input is a BST (Easy)](https://leetcode.com/problems/two-sum-iv-input-is-a-bst/description/)

```html
Input:

    5
   / \
  3   6
 / \   \
2   4   7

Target = 9

Output: True
```

ä½¿ç”¨ä¸­åºéå†å¾—åˆ°æœ‰åºæ•°ç»„ä¹‹åï¼Œå†åˆ©ç”¨åŒæŒ‡é’ˆå¯¹æ•°ç»„è¿›è¡ŒæŸ¥æ‰¾ã€‚

åº”è¯¥æ³¨æ„åˆ°ï¼Œè¿™ä¸€é¢˜ä¸èƒ½ç”¨åˆ†åˆ«åœ¨å·¦å³å­æ ‘ä¸¤éƒ¨åˆ†æ¥å¤„ç†è¿™ç§æ€æƒ³ï¼Œå› ä¸ºä¸¤ä¸ªå¾…æ±‚çš„èŠ‚ç‚¹å¯èƒ½åˆ†åˆ«åœ¨å·¦å³å­æ ‘ä¸­ã€‚

```java
public boolean findTarget(TreeNode root, int k) {
    List<Integer> nums = new ArrayList<>();
    inOrder(root, nums);
    int i = 0, j = nums.size() - 1;
    while (i < j) {
        int sum = nums.get(i) + nums.get(j);
        if (sum == k) return true;
        if (sum < k) i++;
        else j--;
    }
    return false;
}

private void inOrder(TreeNode root, List<Integer> nums) {
    if (root == null) return;
    inOrder(root.left, nums);
    nums.add(root.val);
    inOrder(root.right, nums);
}
```

## åœ¨äºŒå‰æŸ¥æ‰¾æ ‘ä¸­æŸ¥æ‰¾ä¸¤ä¸ªèŠ‚ç‚¹ä¹‹å·®çš„æœ€å°ç»å¯¹å€¼

[530. Minimum Absolute Difference in BST (Easy)](https://leetcode.com/problems/minimum-absolute-difference-in-bst/description/)

```html
Input:

   1
    \
     3
    /
   2

Output:

1
```

åˆ©ç”¨äºŒå‰æŸ¥æ‰¾æ ‘çš„ä¸­åºéå†ä¸ºæœ‰åºçš„æ€§è´¨ï¼Œè®¡ç®—ä¸­åºéå†ä¸­ä¸´è¿‘çš„ä¸¤ä¸ªèŠ‚ç‚¹ä¹‹å·®çš„ç»å¯¹å€¼ï¼Œå–æœ€å°å€¼ã€‚

```java
private int minDiff = Integer.MAX_VALUE;
private TreeNode preNode = null;

public int getMinimumDifference(TreeNode root) {
    inOrder(root);
    return minDiff;
}

private void inOrder(TreeNode node) {
    if (node == null) return;
    inOrder(node.left);
    if (preNode != null) minDiff = Math.min(minDiff, node.val - preNode.val);
    preNode = node;
    inOrder(node.right);
}
```

## å¯»æ‰¾äºŒå‰æŸ¥æ‰¾æ ‘ä¸­å‡ºç°æ¬¡æ•°æœ€å¤šçš„å€¼

[501. Find Mode in Binary Search Tree (Easy)](https://leetcode.com/problems/find-mode-in-binary-search-tree/description/)

```html
   1
    \
     2
    /
   2

return [2].
```

ç­”æ¡ˆå¯èƒ½ä¸æ­¢ä¸€ä¸ªï¼Œä¹Ÿå°±æ˜¯æœ‰å¤šä¸ªå€¼å‡ºç°çš„æ¬¡æ•°ä¸€æ ·å¤šã€‚

```java
private int curCnt = 1;
private int maxCnt = 1;
private TreeNode preNode = null;

public int[] findMode(TreeNode root) {
    List<Integer> maxCntNums = new ArrayList<>();
    inOrder(root, maxCntNums);
    int[] ret = new int[maxCntNums.size()];
    int idx = 0;
    for (int num : maxCntNums) {
        ret[idx++] = num;
    }
    return ret;
}

private void inOrder(TreeNode node, List<Integer> nums) {
    if (node == null) return;
    inOrder(node.left, nums);
    if (preNode != null) {
        if (preNode.val == node.val) curCnt++;
        else curCnt = 1;
    }
    if (curCnt > maxCnt) {
        maxCnt = curCnt;
        nums.clear();
        nums.add(node.val);
    } else if (curCnt == maxCnt) {
        nums.add(node.val);
    }
    preNode = node;
    inOrder(node.right, nums);
}
```

# Trie

<div align="center"> <img src="https://gitee.com/CyC2018/CS-Notes/raw/master/docs/pics/5c638d59-d4ae-4ba4-ad44-80bdc30f38dd.jpg"/> </div><br>

Trieï¼Œåˆç§°å‰ç¼€æ ‘æˆ–å­—å…¸æ ‘ï¼Œç”¨äºåˆ¤æ–­å­—ç¬¦ä¸²æ˜¯å¦å­˜åœ¨æˆ–è€…æ˜¯å¦å…·æœ‰æŸç§å­—ç¬¦ä¸²å‰ç¼€ã€‚

## å®ç°ä¸€ä¸ª Trie

[208. Implement Trie (Prefix Tree) (Medium)](https://leetcode.com/problems/implement-trie-prefix-tree/description/)

```java
class Trie {

    private class Node {
        Node[] childs = new Node[26];
        boolean isLeaf;
    }

    private Node root = new Node();

    public Trie() {
    }

    public void insert(String word) {
        insert(word, root);
    }

    private void insert(String word, Node node) {
        if (node == null) return;
        if (word.length() == 0) {
            node.isLeaf = true;
            return;
        }
        int index = indexForChar(word.charAt(0));
        if (node.childs[index] == null) {
            node.childs[index] = new Node();
        }
        insert(word.substring(1), node.childs[index]);
    }

    public boolean search(String word) {
        return search(word, root);
    }

    private boolean search(String word, Node node) {
        if (node == null) return false;
        if (word.length() == 0) return node.isLeaf;
        int index = indexForChar(word.charAt(0));
        return search(word.substring(1), node.childs[index]);
    }

    public boolean startsWith(String prefix) {
        return startWith(prefix, root);
    }

    private boolean startWith(String prefix, Node node) {
        if (node == null) return false;
        if (prefix.length() == 0) return true;
        int index = indexForChar(prefix.charAt(0));
        return startWith(prefix.substring(1), node.childs[index]);
    }

    private int indexForChar(char c) {
        return c - 'a';
    }
}
```

## å®ç°ä¸€ä¸ª Trieï¼Œç”¨æ¥æ±‚å‰ç¼€å’Œ

[677. Map Sum Pairs (Medium)](https://leetcode.com/problems/map-sum-pairs/description/)

```html
Input: insert("apple", 3), Output: Null
Input: sum("ap"), Output: 3
Input: insert("app", 2), Output: Null
Input: sum("ap"), Output: 5
```

```java
class MapSum {

    private class Node {
        Node[] child = new Node[26];
        int value;
    }

    private Node root = new Node();

    public MapSum() {

    }

    public void insert(String key, int val) {
        insert(key, root, val);
    }

    private void insert(String key, Node node, int val) {
        if (node == null) return;
        if (key.length() == 0) {
            node.value = val;
            return;
        }
        int index = indexForChar(key.charAt(0));
        if (node.child[index] == null) {
            node.child[index] = new Node();
        }
        insert(key.substring(1), node.child[index], val);
    }

    public int sum(String prefix) {
        return sum(prefix, root);
    }

    private int sum(String prefix, Node node) {
        if (node == null) return 0;
        if (prefix.length() != 0) {
            int index = indexForChar(prefix.charAt(0));
            return sum(prefix.substring(1), node.child[index]);
        }
        int sum = node.value;
        for (Node child : node.child) {
            sum += sum(prefix, child);
        }
        return sum;
    }

    private int indexForChar(char c) {
        return c - 'a';
    }
}
```





</br><div align="center">â­ï¸æ¬¢è¿å…³æ³¨æˆ‘çš„å…¬ä¼—å· CyC2018ï¼Œåœ¨å…¬ä¼—å·åå°å›å¤å…³é”®å­— ğŸ“š **èµ„æ–™** å¯é¢†å–å¤ä¹ å¤§çº²ï¼Œè¿™ä»½å¤§çº²æ˜¯æˆ‘èŠ±äº†ä¸€æ•´å¹´æ—¶é—´æ•´ç†çš„é¢è¯•çŸ¥è¯†ç‚¹åˆ—è¡¨ï¼Œä¸ä»…ç³»ç»Ÿæ•´ç†äº†é¢è¯•çŸ¥è¯†ç‚¹ï¼Œè€Œä¸”æ ‡æ³¨äº†å„ä¸ªçŸ¥è¯†ç‚¹çš„é‡è¦ç¨‹åº¦ï¼Œä»è€Œå¸®ä½ ç†æ¸…å¤šè€Œæ‚çš„é¢è¯•çŸ¥è¯†ç‚¹ã€‚å¯ä»¥è¯´æˆ‘åŸºæœ¬æ˜¯æŒ‰ç…§è¿™ä»½å¤§çº²æ¥è¿›è¡Œå¤ä¹ çš„ï¼Œè¿™ä»½å¤§çº²å¯¹æˆ‘æ‹¿åˆ°äº† BAT å¤´æ¡ç­‰ Offer èµ·åˆ°å¾ˆå¤§çš„å¸®åŠ©ã€‚ä½ ä»¬å®Œå…¨å¯ä»¥å’Œæˆ‘ä¸€æ ·æ ¹æ®å¤§çº²ä¸Šåˆ—çš„çŸ¥è¯†ç‚¹æ¥è¿›è¡Œå¤ä¹ ï¼Œå°±ä¸ç”¨çœ‹å¾ˆå¤šä¸é‡è¦çš„å†…å®¹ï¼Œä¹Ÿå¯ä»¥çŸ¥é“å“ªäº›å†…å®¹å¾ˆé‡è¦ä»è€Œå¤šå®‰æ’ä¸€äº›å¤ä¹ æ—¶é—´ã€‚</div></br>
<div align="center"><img width="180px" src="https://cyc-1256109796.cos.ap-guangzhou.myqcloud.com/%E5%85%AC%E4%BC%97%E5%8F%B7.jpg"></img></div>
